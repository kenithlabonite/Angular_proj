
================================================================================
File: .vs\group-project-repo\v17\DocumentLayout.json
Size: 2.56 kB
================================================================================

{
  "Version": 1,
  "WorkspaceRootPath": "C:\\Users\\Kenith Labonite\\group-project-repo\\",
  "Documents": [
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\Kenith Labonite\\group-project-repo\\server.js||{14D17961-FE51-464D-9111-C4AF11D7D99A}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:server.js||{14D17961-FE51-464D-9111-C4AF11D7D99A}"
    },
    {
      "AbsoluteMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|C:\\Users\\Kenith Labonite\\group-project-repo\\accounts\\account.model.js||{14D17961-FE51-464D-9111-C4AF11D7D99A}",
      "RelativeMoniker": "D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\u003CMiscFiles\u003E|solutionrelative:accounts\\account.model.js||{14D17961-FE51-464D-9111-C4AF11D7D99A}"
    }
  ],
  "DocumentGroupContainers": [
    {
      "Orientation": 0,
      "VerticalTabListWidth": 256,
      "DocumentGroups": [
        {
          "DockedWidth": 200,
          "SelectedChildIndex": 0,
          "Children": [
            {
              "$type": "Document",
              "DocumentIndex": 0,
              "Title": "server.js",
              "DocumentMoniker": "C:\\Users\\Kenith Labonite\\group-project-repo\\server.js",
              "RelativeDocumentMoniker": "server.js",
              "ToolTip": "C:\\Users\\Kenith Labonite\\group-project-repo\\server.js",
              "RelativeToolTip": "server.js",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.001646|",
              "WhenOpened": "2025-07-21T14:21:38.787Z",
              "EditorCaption": ""
            },
            {
              "$type": "Document",
              "DocumentIndex": 1,
              "Title": "account.model.js",
              "DocumentMoniker": "C:\\Users\\Kenith Labonite\\group-project-repo\\accounts\\account.model.js",
              "RelativeDocumentMoniker": "accounts\\account.model.js",
              "ToolTip": "C:\\Users\\Kenith Labonite\\group-project-repo\\accounts\\account.model.js",
              "RelativeToolTip": "accounts\\account.model.js",
              "ViewState": "AgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
              "Icon": "ae27a6b0-e345-4288-96df-5eaf394ee369.001646|",
              "WhenOpened": "2025-07-21T14:21:26.704Z",
              "EditorCaption": ""
            }
          ]
        }
      ]
    }
  ]
}

================================================================================
File: .vs\VSWorkspaceState.json
Size: 175 B
================================================================================

{
  "ExpandedNodes": [
    "",
    "\\accounts",
    "\\_helpers",
    "\\_middleware"
  ],
  "SelectedNode": "\\swagger.yaml",
  "PreviewInSolutionExplorer": false
}

================================================================================
File: accounts\account.model.js
Size: 2.06 kB
================================================================================

// accounts/account.model.js
const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        id: {
            type: DataTypes.INTEGER.UNSIGNED,
            primaryKey: true,
            autoIncrement: true
        },
        email: {
            type: DataTypes.STRING(255),
            allowNull: false,
            unique: false
        },
        passwordHash: { type: DataTypes.STRING, allowNull: true },
        title: { type: DataTypes.STRING, allowNull: false },
        firstName: { type: DataTypes.STRING, allowNull: false },
        lastName: { type: DataTypes.STRING, allowNull: false },
        acceptTerms: { type: DataTypes.BOOLEAN },
        role: { type: DataTypes.STRING, allowNull: false },
        verificationToken: { type: DataTypes.STRING },
        verified: { type: DataTypes.DATE },
        resetToken: { type: DataTypes.STRING },
        resetTokenExpires: { type: DataTypes.DATE },
        passwordReset: { type: DataTypes.DATE },
        status: {
            type: DataTypes.ENUM('active', 'inactive'),
            allowNull: false,
            defaultValue: 'active'
        },
        created: {
            type: DataTypes.DATE,
            allowNull: false,
            defaultValue: DataTypes.NOW
        },
        updated: { type: DataTypes.DATE },
        isVerified: {
            type: DataTypes.VIRTUAL,
            get() {
                return !!(this.verified || this.passwordReset);
            }
        }
    };

    const options = {
        tableName: 'accounts',
        // disable default timestamp fields (createdAt and updatedAt)
        timestamps: false,
        defaultScope: {
            // exclude password hash by default
            attributes: { exclude: ['passwordHash'] }
        },
        scopes: {
            // include hash with this scope
            withHash: { attributes: {} }
        }
    };

    return sequelize.define('Account', attributes, options);
}


================================================================================
File: accounts\account.service.js
Size: 9.76 kB
================================================================================

// account.service.js
const config = require('config.json');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { Op } = require('sequelize');
const sendEmail = require('_helpers/send-email');
const db = require('_helpers/db');
const Role = require('_helpers/role');

module.exports = {
  authenticate,
  refreshToken,
  revokeToken,
  register,
  verifyEmail,
  forgotPassword,
  validateResetToken,
  resetPassword,
  getAll,
  getById,
  create,
  update,
  delete: _delete
};

// ------------------------- Authentication -------------------------

async function authenticate({ email, password, ipAddress }) {
  const account = await db.Account.scope('withHash').findOne({ where: { email } });
  if (!account) throw 'Account not found';
  if (account.status && account.status.toLowerCase() === 'inactive') throw 'This account is inactive';
  if (!account.passwordHash) throw 'This account does not have a password set';
  if (!(await bcrypt.compare(password, account.passwordHash))) throw 'Invalid password';

  const jwtToken = generateJwtToken(account);
  const refreshToken = generateRefreshToken(account, ipAddress);
  await refreshToken.save();

  return {
    ...basicDetails(account),
    jwtToken,
    refreshToken: refreshToken.token
  };
}

async function refreshToken({ token, ipAddress }) {
  const refreshToken = await getRefreshToken(token);
  const account = await refreshToken.getAccount();

  const newRefreshToken = generateRefreshToken(account, ipAddress);
  refreshToken.revoked = Date.now();
  refreshToken.revokedByIp = ipAddress;
  refreshToken.replacedByToken = newRefreshToken.token;

  await refreshToken.save();
  await newRefreshToken.save();

  const jwtToken = generateJwtToken(account);

  return {
    ...basicDetails(account),
    jwtToken,
    refreshToken: newRefreshToken.token
  };
}

async function revokeToken({ token, ipAddress }) {
  const refreshToken = await getRefreshToken(token);
  refreshToken.revoked = Date.now();
  refreshToken.revokedByIp = ipAddress;
  await refreshToken.save();
}

// ------------------------- Registration / Verification -------------------------

async function register(params, origin) {
  if (await db.Account.findOne({ where: { email: params.email } })) {
    return await sendAlreadyRegisteredEmail(params.email, origin);
  }

  const account = new db.Account(params);

  const isFirstAccount = (await db.Account.count()) === 0;
  account.role = isFirstAccount ? Role.Admin : Role.User;
  account.verificationToken = randomTokenString();
  account.passwordHash = await hash(params.password);

  await account.save();
  await sendVerificationEmail(account, origin);
}

async function verifyEmail({ token }) {
  const account = await db.Account.findOne({ where: { verificationToken: token } });
  if (!account) throw 'Verification failed';

  account.verified = Date.now();
  account.verificationToken = null;
  await account.save();
}

// ------------------------- Password reset -------------------------

async function forgotPassword({ email }, origin) {
  const account = await db.Account.findOne({ where: { email } });
  if (!account) return; // always OK

  account.resetToken = randomTokenString();
  account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000);
  await account.save();

  await sendPasswordResetEmail(account, origin);
}

async function validateResetToken({ token }) {
  const account = await db.Account.findOne({
    where: { resetToken: token, resetTokenExpires: { [Op.gt]: Date.now() } }
  });
  if (!account) throw 'Invalid token';
  return account;
}

async function resetPassword({ token, password, confirmPassword }) {
  const account = await validateResetToken({ token });
  if (!password) throw 'Password is required';
  if (!confirmPassword) throw 'Confirm password is required';
  if (password !== confirmPassword) throw 'Passwords do not match';

  account.passwordHash = await hash(password);
  account.passwordReset = Date.now();
  account.resetToken = null;
  await account.save();
}

// ------------------------- CRUD -------------------------

async function getAll() {
  return await db.Account.findAll({
    attributes: ['id', 'title', 'firstName', 'lastName', 'email', 'role', 'status', 'created', 'updated', 'isVerified']
  });
}

async function getById(id) {
  const account = await getAccount(id);
  return account ? basicDetails(account) : null;
}

async function create(params) {
  console.log('Incoming create params:', params);

  // check email
  if (await db.Account.findOne({ where: { email: params.email } })) {
    throw `Email "${params.email}" is already registered`;
  }

  // ✅ enforce password requirements
  if (!params.password) throw 'Password is required';
  if (!params.confirmPassword) throw 'Confirm password is required';
  if (params.password !== params.confirmPassword) {
    throw 'Passwords do not match';
  }

  // build account
  const account = new db.Account({
    title: params.title,
    firstName: params.firstName,
    lastName: params.lastName,
    email: params.email,
    role: params.role,
    status: params.status,
    verified: Date.now(), // ✅ admin-created accounts are auto-verified
    passwordHash: await hash(params.password)
  });

  await account.save();
  return basicDetails(account);
}

async function update(id, params) {
  const account = await getAccount(id);
  if (!account) throw 'Account not found';

  if (params.email && account.email !== params.email &&
      await db.Account.findOne({ where: { email: params.email } })) {
    throw `Email "${params.email}" is already taken`;
  }

  if (params.password || params.confirmPassword) {
    if (!params.password) throw 'Password is required';
    if (!params.confirmPassword) throw 'Confirm password is required';
    if (params.password !== params.confirmPassword) {
      throw 'Passwords do not match';
    }
    params.passwordHash = await hash(params.password);
  }

  Object.assign(account, params);
  account.updated = Date.now();
  await account.save();

  return basicDetails(account);
}

async function _delete(id) {
  const account = await getAccount(id);
  if (!account) throw 'Account not found';
  await account.destroy();
}

// ------------------------- Helpers -------------------------

async function getAccount(id) {
  return await db.Account.findByPk(id);
}

async function getRefreshToken(token) {
  const refreshToken = await db.RefreshToken.findOne({ where: { token } });
  if (!refreshToken || !refreshToken.isActive) throw 'Invalid token';
  return refreshToken;
}

async function hash(password) {
  return await bcrypt.hash(password, 10);
}

function generateJwtToken(account) {
  return jwt.sign({ sub: account.id, id: account.id }, config.secret, { expiresIn: '15m' });
}

function generateRefreshToken(account, ipAddress) {
  return new db.RefreshToken({
    accountId: account.id,
    token: randomTokenString(),
    expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    createdByIp: ipAddress
  });
}

function randomTokenString() {
  return crypto.randomBytes(40).toString('hex');
}

function basicDetails(account) {
  const { id, title, firstName, lastName, email, role, status, created, updated, isVerified } = account;
  return { id, title, firstName, lastName, email, role, status, created, updated, isVerified };
}

// ------------------------- Email helpers -------------------------

async function sendVerificationEmail(account, origin) {
  let message;
  if (origin) {
    const verifyUrl = `${origin}/account/verify-email?token=${account.verificationToken}`;
    message = `<p>Please click the below link to verify your email address:</p>
               <p><a href="${verifyUrl}">${verifyUrl}</a></p>`;
  } else {
    message = `<p>Please use the below token to verify your email address with the <code>/account/verify-email</code> api route:</p>
               <p><code>${account.verificationToken}</code></p>`;
  }

  await sendEmail({
    to: account.email,
    subject: 'Verify Email',
    html: `<h4>Verify Email</h4>
           <p>Thanks for registering!</p>
           ${message}`
  });
}

async function sendAlreadyRegisteredEmail(email, origin) {
  let message;
  if (origin) {
    message = `<p>If you don't know your password please visit the <a href="${origin}/account/forgot-password">forgot password</a> page.</p>`;
  } else {
    message = `<p>If you don't know your password you can reset it via the <code>/account/forgot-password</code> api route.</p>`;
  }

  await sendEmail({
    to: email,
    subject: 'Email Already Registered',
    html: `<h4>Email Already Registered</h4>
           <p>Your email <strong>${email}</strong> is already registered.</p>
           ${message}`
  });
}

async function sendPasswordResetEmail(account, origin) {
  let message;
  if (origin) {
    const resetUrl = `${origin}/account/reset-password?token=${account.resetToken}`;
    message = `<p>Please click the below link to reset your password, the link will be valid for 1 day:</p>
               <p><a href="${resetUrl}">${resetUrl}</a></p>`;
  } else {
    message = `<p>Please use the below token to reset your password with the <code>/account/reset-password</code> api route:</p>
               <p><code>${account.resetToken}</code></p>`;
  }

  await sendEmail({
    to: account.email,
    subject: 'Reset Password',
    html: `<h4>Reset Password</h4>
           ${message}`
  });
}


================================================================================
File: accounts\accounts.controller.js
Size: 9.13 kB
================================================================================

﻿const express = require('express');
const router = express.Router();
const Joi = require('joi');
const validateRequest = require('_middleware/validate-request');
const authorize = require('_middleware/authorize');
const Role = require('_helpers/role');
const accountService = require('./account.service');

// -------------------- ROUTES --------------------
router.post('/authenticate', authenticateSchema, authenticate);
router.post('/refresh-token', refreshToken);
router.post('/revoke-token', authorize(), revokeTokenSchema, revokeToken);
router.post('/register', registerSchema, register);
router.post('/verify-email', verifyEmailSchema, verifyEmail);
router.post('/forgot-password', forgotPasswordSchema, forgotPassword);
router.post('/validate-reset-token', validateResetTokenSchema, validateResetToken);
router.post('/reset-password', resetPasswordSchema, resetPassword);

router.get('/', authorize(Role.Admin), getAll);
router.get('/:id', authorize(), getById);
router.post('/', authorize(Role.Admin), createSchema, create);
router.put('/:id', authorize(), updateSchema, update);
router.delete('/:id', authorize(), _delete);

module.exports = router;

// -------------------- SCHEMAS & HANDLERS --------------------

function authenticateSchema(req, res, next) {
  const schema = Joi.object({
    email: Joi.string().required(),
    password: Joi.string().required()
  });
  validateRequest(req, next, schema);
}

function authenticate(req, res, next) {
  const { email, password } = req.body;
  const ipAddress = req.ip;

  accountService.authenticate({ email, password, ipAddress })
    .then(result => {
      if (!result) return res.status(400).json({ message: 'Email or password is incorrect' });

      const account = result.account || result;
      const jwtToken = result.jwtToken || (account && account.jwtToken);
      const refreshToken = result.refreshToken || (result.account && result.refreshToken);

      if (!account) return res.status(400).json({ message: 'Email or password is incorrect' });
      if (refreshToken) setTokenCookie(res, refreshToken);

      const response = { ...account };
      if (jwtToken) response.jwtToken = jwtToken;

      return res.json(response);
    })
    .catch(next);
}

function refreshToken(req, res, next) {
  const token = req.cookies && req.cookies.refreshToken;
  const ipAddress = req.ip;

  accountService.refreshToken({ token, ipAddress })
    .then(result => {
      if (!result) return res.status(400).json({ message: 'Invalid token' });

      const refreshToken = result.refreshToken;
      const account = result.account || result;

      if (refreshToken) setTokenCookie(res, refreshToken);
      return res.json(account);
    })
    .catch(next);
}

function revokeTokenSchema(req, res, next) {
  const schema = Joi.object({
    token: Joi.string().empty('')
  });
  validateRequest(req, next, schema);
}

function revokeToken(req, res, next) {
  const token = req.body.token || (req.cookies && req.cookies.refreshToken);
  const ipAddress = req.ip;

  if (!token) return res.status(400).json({ message: 'Token is required' });
  if (!req.user) return res.status(401).json({ message: 'Unauthorized' });

  const owns = typeof req.user.ownsToken === 'function' ? req.user.ownsToken(token) : false;
  if (!owns && req.user.role !== Role.Admin) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  accountService.revokeToken({ token, ipAddress })
    .then(() => res.json({ message: 'Token revoked' }))
    .catch(next);
}

function registerSchema(req, res, next) {
  const schema = Joi.object({
    title: Joi.string().required(),
    firstName: Joi.string().required(),
    lastName: Joi.string().required(),
    email: Joi.string().email().required(),
    password: Joi.string().min(6).required(),
    confirmPassword: Joi.string().valid(Joi.ref('password')).required(),
    acceptTerms: Joi.boolean().valid(true).required()
  });
  validateRequest(req, next, schema);
}

function register(req, res, next) {
  accountService.register(req.body, req.get('origin'))
    .then(() => res.json({ message: 'Registration successful, please check your email for verification instructions' }))
    .catch(next);
}

function verifyEmailSchema(req, res, next) {
  const schema = Joi.object({
    token: Joi.string().required()
  });
  validateRequest(req, next, schema);
}

function verifyEmail(req, res, next) {
  accountService.verifyEmail(req.body)
    .then(() => res.json({ message: 'Verification successful, you can now login' }))
    .catch(next);
}

function forgotPasswordSchema(req, res, next) {
  const schema = Joi.object({
    email: Joi.string().email().required()
  });
  validateRequest(req, next, schema);
}

function forgotPassword(req, res, next) {
  accountService.forgotPassword(req.body, req.get('origin'))
    .then(() => res.json({ message: 'Please check your email for password reset instructions' }))
    .catch(next);
}

function validateResetTokenSchema(req, res, next) {
  const schema = Joi.object({
    token: Joi.string().required()
  });
  validateRequest(req, next, schema);
}

function validateResetToken(req, res, next) {
  accountService.validateResetToken(req.body)
    .then(() => res.json({ message: 'Token is valid' }))
    .catch(next);
}

function resetPasswordSchema(req, res, next) {
  const schema = Joi.object({
    token: Joi.string().required(),
    password: Joi.string().min(6).required(),
    confirmPassword: Joi.string().valid(Joi.ref('password')).required()
  });
  validateRequest(req, next, schema);
}

function resetPassword(req, res, next) {
  accountService.resetPassword(req.body)
    .then(() => res.json({ message: 'Password reset successful, you can now login' }))
    .catch(next);
}

function getAll(req, res, next) {
  accountService.getAll()
    .then(accounts => res.json(accounts))
    .catch(next);
}

function getById(req, res, next) {
  if (!req.user) return res.status(401).json({ message: 'Unauthorized' });
  if (String(req.params.id) !== String(req.user.id) && req.user.role !== Role.Admin) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  accountService.getById(req.params.id)
    .then(account => account ? res.json(account) : res.sendStatus(404))
    .catch(next);
}

function createSchema(req, res, next) {
  const schema = Joi.object({
    title: Joi.string().required(),
    firstName: Joi.string().required(),
    lastName: Joi.string().required(),
    email: Joi.string().email().required(),
    role: Joi.string().valid(Role.Admin, Role.User).required(),
    status: Joi.string().valid('active', 'inactive').required(),
    password: Joi.string().min(6).required(),
    confirmPassword: Joi.string().valid(Joi.ref('password')).required()
  });
  validateRequest(req, next, schema);
}

function create(req, res, next) {
  accountService.create(req.body)
    .then(account => res.json(account))
    .catch(next);
}

function updateSchema(req, res, next) {
  const schemaRules = {
    title: Joi.string().empty(''),
    firstName: Joi.string().empty(''),
    lastName: Joi.string().empty(''),
    email: Joi.string().email().empty(''),
    password: Joi.string().min(6).empty(''),
    confirmPassword: Joi.string().valid(Joi.ref('password')).empty('')
  };

  if (req.user && req.user.role === Role.Admin) {
    schemaRules.role = Joi.string().valid(Role.Admin, Role.User).empty('');
    schemaRules.status = Joi.string().valid('active', 'inactive').empty('');
  }

  const schema = Joi.object(schemaRules).with('password', 'confirmPassword');
  validateRequest(req, next, schema);
}

function update(req, res, next) {
  if (!req.user) return res.status(401).json({ message: 'Unauthorized' });
  if (String(req.params.id) !== String(req.user.id) && req.user.role !== Role.Admin) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  const allowedFields = ['title', 'firstName', 'lastName', 'email', 'password', 'confirmPassword'];
  if (req.user.role === Role.Admin) allowedFields.push('role', 'status');

  const params = {};
  for (const field of allowedFields) {
    if (Object.prototype.hasOwnProperty.call(req.body, field)) params[field] = req.body[field];
  }

  accountService.update(req.params.id, params)
    .then(account => res.json(account))
    .catch(next);
}

function _delete(req, res, next) {
  accountService.delete(req.params.id)
    .then(() => res.json({ message: 'Account deleted successfully' }))
    .catch(next);
}

// -------------------- HELPERS --------------------
function setTokenCookie(res, token) {
  const cookieOptions = {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production', // only secure cookies in prod
    sameSite: 'none', // allow cookies across domains (Vercel <-> Render)
    expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  };
  res.cookie('refreshToken', token, cookieOptions);
}


================================================================================
File: accounts\refresh-token.model.js
Size: 981 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        token: { type: DataTypes.STRING },
        expires: { type: DataTypes.DATE },
        created: { type: DataTypes.DATE, allowNull: false, defaultValue: DataTypes.NOW },
        createdByIp: { type: DataTypes.STRING },
        revoked: { type: DataTypes.DATE },
        revokedByIp: { type: DataTypes.STRING },
        replacedByToken: { type: DataTypes.STRING },
        isExpired: {
            type: DataTypes.VIRTUAL,
            get() { return Date.now() >= this.expires; }
        },
        isActive: {
            type: DataTypes.VIRTUAL,
            get() { return !this.revoked && !this.isExpired; }
        }
    };

    const options = {
        // disable default timestamp fields (createdAt and updatedAt)
        timestamps: false
    };

    return sequelize.define('refreshToken', attributes, options);
}


================================================================================
File: config.js
Size: 755 B
================================================================================


// module.exports = {
//   database: {
//     host: process.env.DB_HOST || 'localhost',
//     port: process.env.DB_PORT || 3306,
//     user: process.env.DB_USER || 'root',
//     password: process.env.DB_PASSWORD || 'bg5yi45i',
//     database: process.env.DB_NAME || 'node-mysql-signup-verification-api',
//   },
//   secret: process.env.JWT_SECRET || 'default-secret',
//   emailFrom: process.env.EMAIL_FROM || 'info@example.com',
//   smtpOptions: {
//     host: process.env.SMTP_HOST || 'smtp.ethereal.email',
//     port: process.env.SMTP_PORT || 587,
//     auth: {
//       user: process.env.SMTP_USER || 'shyanne.hills25@ethereal.email',
//       pass: process.env.SMTP_PASS || 'QkMGGHJaq2WcpKHME6',
//     },
//   },
// };


================================================================================
File: config.json
Size: 540 B
================================================================================

{
    "database": {
        "host": "localhost",
        "port": 3306,
        "user": "root",
        "password": "bg5yi45i",
        "database": "node-mysql-signup-verification-api"
    },
    "secret": "49857eae-5b2d-4e74-b5e7-99953f347936",
    "emailFrom": "info@node-mysql-signup-verification-api.com",
    "smtpOptions": {
        "host": "smtp.ethereal.email",
        "port": 587,
        "auth": {
            "user": "shyanne.hills25@ethereal.email",
            "pass": "QkMGGHJaq2WcpKHME6"
        }
    }
}


================================================================================
File: departments\department.controller.js
Size: 1.03 kB
================================================================================

const service = require('./department.service');

module.exports = { 
  getAll, 
  getById, 
  create, 
  update, 
  delete: _delete };

async function getAll(req, res, next) {
  try {
    const depts = await service.getAll();
    res.json(depts);
  } catch (err) { next(err); }
}

async function getById(req, res, next) {
  try {
    const dept = await service.getById(req.params.id);
    if (!dept) return res.sendStatus(404);
    res.json(dept);
  } catch (err) { next(err); }
}

async function create(req, res, next) {
  try {
    const dept = await service.create(req.body);
    res.status(201).json(dept);
  } catch (err) { next(err); }
}

async function update(req, res, next) {
  try {
    const dept = await service.update(req.params.id, req.body);
    res.json(dept);
  } catch (err) { next(err); }
}

async function _delete(req, res, next) {
  try {
    await service.delete(req.params.id);
    res.json({ message: 'Department deleted' });
  } catch (err) { next(err); }
}




================================================================================
File: departments\department.model.js
Size: 850 B
================================================================================

// departments/department.model.js
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    departmentName: {
      type: DataTypes.STRING,
      allowNull: false
    },
    description: {
      type: DataTypes.STRING
    },
    employeeCounts: {
      type: DataTypes.INTEGER,
      defaultValue: 0
    }
  };

  const options = {
    tableName: 'departments',
    timestamps: false
  };

  const Department = sequelize.define('Department', attributes, options);

  Department.associate = (models) => {
    Department.hasMany(models.Employee, {
      foreignKey: 'departmentId',
      sourceKey: 'id',
      as: 'Employees'
    });
  };

  return Department;
};


================================================================================
File: departments\department.service.js
Size: 2.09 kB
================================================================================

// departments/department.service.js
const db = require('_helpers/db');

module.exports = {
  getAll,
  getById,
  create,
  update,
  delete: _delete
};

// ====== QUERIES ======

async function getAll() {
  const departments = await db.Department.findAll({
    include: [
      { model: db.Employee, as: 'Employees', attributes: ['EmployeeID', 'position', 'status'] }
    ],
    order: [['id', 'ASC']]
  });

  // recalc employeeCounts in case it's out of sync
  for (const dept of departments) {
    const count = dept.Employees ? dept.Employees.length : 0;
    if (dept.employeeCounts !== count) {
      dept.employeeCounts = count;
      await dept.save();
    }
  }

  return departments;
}

async function getById(id) {
  const department = await db.Department.findByPk(id, {
    include: [
      { model: db.Employee, as: 'Employees', attributes: ['EmployeeID', 'position', 'status'] }
    ]
  });
  if (!department) throw 'Department not found';

  // recalc employeeCounts if needed
  const count = department.Employees ? department.Employees.length : 0;
  if (department.employeeCounts !== count) {
    department.employeeCounts = count;
    await department.save();
  }

  return department;
}

// ====== CREATE ======

async function create(params) {
  const department = new db.Department({
    departmentName: params.departmentName,
    description: params.description || null,
    employeeCounts: 0
  });

  await department.save();
  return department;
}

// ====== UPDATE ======

async function update(id, params) {
  const department = await getById(id);
  if (!department) throw 'Department not found';

  const allowed = ['departmentName', 'description'];
  for (const f of allowed) {
    if (params[f] !== undefined) department[f] = params[f];
  }

  await department.save();
  return department;
}

// ====== DELETE ======

async function _delete(id) {
  const department = await getById(id);
  if (!department) throw 'Department not found';

  await department.destroy();
}


================================================================================
File: departments\index.js
Size: 454 B
================================================================================

// departments/index.js
const express = require('express');
const router = express.Router();
const controller = require('./department.controller');

// ✅ Each route points to a function, not the whole controller object
router.get('/', controller.getAll);
router.get('/:id', controller.getById);
router.post('/', controller.create);
router.put('/:id', controller.update);
router.delete('/:id', controller.delete);

module.exports = router;


================================================================================
File: employees\employee.controller.js
Size: 4.62 kB
================================================================================

// employees/employees.controller.js
const express = require('express');
const router = express.Router();
const employeeService = require('./employee.service');
const authorize = require('_middleware/authorize');
const Role = require('_helpers/role');
const db = require('../_helpers/db'); // needed for direct employee lookup

// ===== Routes =====
router.get('/', /* authorize(Role.Admin), */ getAll);
router.get('/next-id', /* authorize(Role.Admin), */ getNextId);
router.get('/:id', /* authorize(Role.Admin), */ getById);
router.post('/', /* authorize(Role.Admin), */ create);
router.put('/:id', /* authorize(Role.Admin), */ update);
router.delete('/:id', authorize(Role.Admin), _delete);
router.post('/:id/transfer', /* authorize(Role.Admin), */ transferDepartment);

module.exports = router;

// ===== Controller Handlers =====

// Get all employees (with Department + Account)
async function getAll(req, res, next) {
  try {
    const employees = await employeeService.getAll({
      includeDepartment: true,
      includeAccount: true
    });
    res.json(employees);
  } catch (err) {
    console.error('Error in getAll:', err);
    next(err);
  }
}

// Generate next EmployeeID
async function getNextId(req, res, next) {
  try {
    const nextId = await employeeService.generateNextEmployeeID();
    res.json({ nextId });
  } catch (err) {
    console.error('Error in getNextId:', err);
    next(err);
  }
}

// Get one employee by EmployeeID
async function getById(req, res, next) {
  try {
    const employee = await employeeService.getById(req.params.id, {
      includeDepartment: true,
      includeAccount: true
    });
    if (!employee) return res.sendStatus(404);
    res.json(employee);
  } catch (err) {
    console.error('Error in getById:', err);
    next(err);
  }
}

// ✅ Create new employee with hireDate validation
async function create(req, res, next) {
  try {
    const { hireDate } = req.body;

    if (!hireDate) {
      return res.status(400).json({ message: 'Hire date is required' });
    }

    const inputDate = new Date(hireDate);
    const today = new Date();

    // Normalize both to YYYY-MM-DD (ignore time)
    const formatDate = d => d.toISOString().split('T')[0];
    const hireDateOnly = formatDate(inputDate);
    const todayOnly = formatDate(today);

    // ❌ Reject if hireDate is in the future
    if (hireDateOnly > todayOnly) {
      return res.status(400).json({ message: 'Hire date cannot be in the future.' });
    }

    // ✅ Continue creating employee
    const employee = await employeeService.create(req.body);
    res.status(201).json(employee);
  } catch (err) {
    console.error('Error in create:', err);
    next(err);
  }
}

// ✅ Update existing employee with hireDate validation
async function update(req, res, next) {
  try {
    const { hireDate } = req.body;

    if (hireDate) {
      const inputDate = new Date(hireDate);
      const today = new Date();

      const formatDate = d => d.toISOString().split('T')[0];
      const hireDateOnly = formatDate(inputDate);
      const todayOnly = formatDate(today);

      if (hireDateOnly > todayOnly) {
        return res.status(400).json({ message: 'Hire date cannot be in the future.' });
      }
    }

    const employee = await employeeService.update(req.params.id, req.body);
    res.json(employee);
  } catch (err) {
    console.error('Error in update:', err);
    next(err);
  }
}

// Delete employee
async function _delete(req, res, next) {
  try {
    await employeeService.delete(req.params.id);
    res.json({ message: 'Employee deleted successfully' });
  } catch (err) {
    console.error('Error in delete:', err);
    next(err);
  }
}

// Transfer employee to another department
async function transferDepartment(req, res, next) {
  try {
    const employeeId = req.params.id;
    const { toDeptId } = req.body;

    if (!toDeptId) {
      return res.status(400).json({ message: 'toDeptId is required' });
    }

    const employee = await db.Employee.findByPk(employeeId);
    if (!employee) {
      return res.status(404).json({ message: 'Employee not found' });
    }

    const fromDeptId = employee.departmentId;
    employee.departmentId = toDeptId;
    await employee.save();

    res.json({
      message: `Employee ${employeeId} transferred successfully`,
      fromDeptId,
      toDeptId,
      employee
    });
  } catch (err) {
    console.error('Error in transferDepartment:', err);
    next(err);
  }
}


================================================================================
File: employees\employee.model.js
Size: 2.15 kB
================================================================================

// employees/employee.model.js
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Employee = sequelize.define(
    'Employee',
    {
      EmployeeID: {
  type: DataTypes.STRING(20),
  allowNull: false,
  primaryKey: true,
  field: 'EmployeeID',
},


      accountId: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: false,
        references: {
          model: 'accounts',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },

      position: {
        type: DataTypes.STRING(100),
        allowNull: true,
      },

      departmentId: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: true,
        references: {
          model: 'departments',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL',
      },

      hireDate: {
        type: DataTypes.DATEONLY,
        allowNull: true,
      },

      status: {
        type: DataTypes.ENUM('active', 'inactive'),
        allowNull: false,
        defaultValue: 'active',
      },

      createdAt: {
        type: DataTypes.DATE,
        allowNull: true,
        field: 'created',
      },

      updatedAt: {
        type: DataTypes.DATE,
        allowNull: true,
        field: 'updated',
      },
    },
    {
      tableName: 'employees',
      timestamps: true,
      createdAt: 'created',
      updatedAt: 'updated',
    }
  );

  // 🔗 Associations
  Employee.associate = (models) => {
    if (models.Account) {
      Employee.belongsTo(models.Account, {
        foreignKey: 'accountId',
        targetKey: 'id',
        as: 'Account',
      });
    }

    if (models.Department) {
      Employee.belongsTo(models.Department, {
        foreignKey: 'departmentId',
        targetKey: 'id',
        as: 'Department',
      });
    }

    if (models.Workflow) {
      Employee.hasMany(models.Workflow, {
        foreignKey: 'employeeId',
        sourceKey: 'EmployeeID',
        as: 'Workflows',
      });
    }
  };

  return Employee;
};


================================================================================
File: employees\employee.service.js
Size: 6.62 kB
================================================================================

// employees/employee.service.js
const db = require('_helpers/db');

module.exports = {
  getAll,
  getById,
  create,
  update,
  delete: _delete,
  generateNextEmployeeID
};

const ALLOWED_STATUS = ['active', 'inactive'];

// ====== QUERIES ======
async function getAll() {
  return await db.Employee.findAll({
    include: [
      { model: db.Account, as: 'Account' },
      { model: db.Department, as: 'Department', attributes: ['id', 'departmentName', 'employeeCounts'] },
      { model: db.Workflow }
    ],
    order: [['created', 'DESC']]
  });
}

async function getById(id) {
  return await db.Employee.findByPk(id, {
    include: [
      { model: db.Account, as: 'Account' },
      { model: db.Department, as: 'Department', attributes: ['id', 'departmentName', 'employeeCounts'] },
      { model: db.Workflow }
    ]
  });
}

async function generateNextEmployeeID() {
  const last = await db.Employee.findOne({ order: [['EmployeeID', 'DESC']] });
  let nextNum = 1;
  if (last && last.EmployeeID) {
    const match = String(last.EmployeeID).match(/EMP0*([0-9]+)$/i);
    if (match && match[1]) nextNum = parseInt(match[1], 10) + 1;
    else nextNum = (await db.Employee.count()) + 1;
  }
  return `EMP${String(nextNum).padStart(3, '0')}`;
}

// ====== HELPERS ======
async function resolveAccount(params) {
  if (params.accountId) {
    const account = await db.Account.findByPk(params.accountId);
    if (!account) throw 'Related account not found for given accountId';
    return account;
  }
  if (params.email) {
    const account = await db.Account.findOne({ where: { email: params.email } });
    if (!account) throw 'Related account not found for given email';
    return account;
  }
  throw 'Please supply accountId or email for related account';
}

function normalizeStatus(raw) {
  const s = (raw === undefined || raw === null) ? '' : String(raw).trim().toLowerCase();
  return s;
}

async function updateDepartmentCount(departmentId) {
  if (!departmentId) return;
  const count = await db.Employee.count({ where: { departmentId } });
  const dept = await db.Department.findByPk(departmentId);
  if (dept) {
    dept.employeeCounts = count;
    await dept.save();
  }
}

// ====== CREATE ======
async function create(params) {
  if (!params || (!params.accountId && !params.email)) {
    throw 'Please supply accountId or email for related account';
  }

  const account = await resolveAccount(params);
  const incomingStatus = normalizeStatus(params.status) || 'active';
  if (!ALLOWED_STATUS.includes(incomingStatus)) throw 'Invalid status';

  // ensure one employee per account
  const existingForAccount = await db.Employee.findOne({ where: { accountId: account.id } });
  if (existingForAccount) throw 'Employee for this account already exists';

  const base = {
    accountId: account.id,
    position: params.position || null,
    departmentId: params.departmentId || null,
    hireDate: params.hireDate || null,
    status: incomingStatus,
    created: new Date()
  };

  let employee = null;
  if (params.EmployeeID) {
    employee = await db.Employee.create({ ...base, EmployeeID: params.EmployeeID });
  } else {
    for (let attempt = 1; attempt <= 5; attempt++) {
      const candidateId = await generateNextEmployeeID();
      try {
        employee = await db.Employee.create({ ...base, EmployeeID: candidateId });
        break;
      } catch (err) {
        if (err.name === 'SequelizeUniqueConstraintError' && attempt < 5) continue;
        throw err;
      }
    }
    if (!employee) throw 'Failed to generate unique EmployeeID';
  }

  if (employee.departmentId) await updateDepartmentCount(employee.departmentId);

  // create onboarding workflow
  try {
    const dept = employee.departmentId ? await db.Department.findByPk(employee.departmentId) : null;
    await db.Workflow.create({
      employeeId: employee.EmployeeID,
      type: 'Onboarding',
      details: `Onboarded to ${dept ? dept.departmentName : 'No Department'} as ${employee.position || 'Unassigned'} on ${employee.hireDate || 'N/A'}`,
      status: 'pending'
    });
  } catch (wfErr) {
    console.error('Failed to create onboarding workflow:', wfErr);
  }

  return await getById(employee.EmployeeID);
}

// ====== UPDATE ======
async function update(id, params) {
  const employee = await db.Employee.findByPk(id);
  if (!employee) throw 'Employee not found';

  const oldDeptId = employee.departmentId;

  if (params.accountId && params.accountId !== employee.accountId) {
    const account = await db.Account.findByPk(params.accountId);
    if (!account) throw 'Related account not found for new accountId';
    const duplicate = await db.Employee.findOne({ where: { accountId: params.accountId } });
    if (duplicate && String(duplicate.EmployeeID) !== String(id)) throw 'Employee for this account already exists';
    employee.accountId = params.accountId;
  }

  const allowed = ['position', 'departmentId', 'hireDate', 'status'];
  for (const f of allowed) {
    if (Object.prototype.hasOwnProperty.call(params, f)) employee[f] = params[f];
  }

  if (params.status) {
    const s = normalizeStatus(params.status);
    if (!ALLOWED_STATUS.includes(s)) throw 'Invalid status';
    employee.status = s;
  }

  employee.updated = new Date();
  await employee.save();

  // update department counts
  if (oldDeptId && oldDeptId !== employee.departmentId) {
    await updateDepartmentCount(oldDeptId);
  }
  if (employee.departmentId && oldDeptId !== employee.departmentId) {
    await updateDepartmentCount(employee.departmentId);

    // 🔥 create workflow for transfer
    try {
      const newDept = await db.Department.findByPk(employee.departmentId);
      const oldDept = oldDeptId ? await db.Department.findByPk(oldDeptId) : null;
      await db.Workflow.create({
        employeeId: employee.EmployeeID,
        type: 'Transfer',
        details: `Transferred from ${oldDept ? oldDept.departmentName : 'None'} to ${newDept ? newDept.departmentName : 'None'}`,
        status: 'pending'
      });
    } catch (wfErr) {
      console.error('Failed to create transfer workflow:', wfErr);
    }
  }

  return await getById(id);
}

// ====== DELETE ======
async function _delete(id) {
  const employee = await db.Employee.findByPk(id);
  if (!employee) throw 'Employee not found';
  const deptId = employee.departmentId;
  await employee.destroy();
  if (deptId) await updateDepartmentCount(deptId);
}


================================================================================
File: package.json
Size: 997 B
================================================================================

{
  "name": "mysql-boilerplate",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node ./server.js",
    "start:dev": "nodemon ./server.js",
    "export:all": "folder2txt --output Backend1.txt C:/Users/Kenith Labonite/group-project-repo --exclude node_modules"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "NodeJS and MySQL for REST API Sign Up with verification, Authentication & Forgot Password",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "bcryptjs": "^3.0.2",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^5.1.0",
    "express-jwt": "^8.5.1",
    "folder2txt": "^1.0.2",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "mysql2": "^3.14.0",
    "nodemailer": "^6.10.0",
    "rootpath": "^0.1.2",
    "sequelize": "^6.37.7",
    "swagger-ui-express": "^5.0.1",
    "yamljs": "^0.3.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  }
}


================================================================================
File: positions\position.controller.js
Size: 1.48 kB
================================================================================

// positions/position.controller.js
const express = require('express');
const router = express.Router();
const positionService = require('./position.service'); // ✅ fixed path

// Routes
router.get('/', getAll);
router.get('/:id', getById);
router.post('/', create);
router.put('/:id', update);
router.delete('/:id', remove);

module.exports = router;

// Controller functions
async function getAll(req, res, next) {
  try {
    const positions = await positionService.getAll();
    res.json(positions);
  } catch (err) {
    next(err);
  }
}

async function getById(req, res, next) {
  try {
    const position = await positionService.getById(req.params.id);
    res.json(position);
  } catch (err) {
    res.status(404).json({ message: err.message });
  }
}

async function create(req, res, next) {
  try {
    const position = await positionService.create(req.body);
    res.status(201).json(position);
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
}

async function update(req, res, next) {
  try {
    const position = await positionService.update(req.params.id, req.body);
    res.json(position);
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
}

async function remove(req, res, next) {
  try {
    const result = await positionService.remove(req.params.id);
    res.json(result);
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
}


================================================================================
File: positions\position.model.js
Size: 407 B
================================================================================

// positions/position.model.js
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Position = sequelize.define('Position', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    position: {
      type: DataTypes.STRING(100),
      allowTopic: false,
      unique: true
    }
  });

  return Position;
};


================================================================================
File: positions\position.service.js
Size: 1.52 kB
================================================================================

// positions/position.service.js
const db = require('../_helpers/db');

module.exports = {
  getAll,
  getById,
  create,
  update,
  remove
};

// ✅ Get all positions
async function getAll() {
  return await db.Position.findAll();
}

// ✅ Get a position by ID
async function getById(id) {
  const position = await db.Position.findByPk(id);
  if (!position) throw new Error('Position not found');
  return position;
}

// ✅ Create a new position
async function create(params) {
  if (!params.position) throw new Error('Position name is required');

  const existing = await db.Position.findOne({ where: { position: params.position } });
  if (existing) throw new Error(`Position "${params.position}" already exists`);

  const newPosition = await db.Position.create(params);
  return newPosition;
}

// ✅ Update a position by ID
async function update(id, params) {
  const position = await getById(id);

  // Check for duplicate if updating name
  if (params.position && params.position !== position.position) {
    const duplicate = await db.Position.findOne({ where: { position: params.position } });
    if (duplicate) throw new Error(`Position "${params.position}" already exists`);
  }

  Object.assign(position, params);
  await position.save();
  return position;
}

// ✅ Delete a position by ID
async function remove(id) {
  const position = await getById(id);
  await position.destroy();
  return { message: 'Position deleted successfully' };
}


================================================================================
File: README.md
Size: 15 B
================================================================================

# Angular_proj


================================================================================
File: requests\index.js
Size: 519 B
================================================================================

// requests/index.js
const express = require('express');
const router = express.Router();
const controller = require('./request.controller');

router.get('/', controller.getAll);
router.get('/:requestId', controller.getById);
router.post('/', controller.createSchema, controller.create);
router.put('/:requestId', controller.updateSchema, controller.update);
router.post('/:requestId', controller.updateSchema, controller.update);
router.delete('/:requestId', controller.delete);

module.exports = router;


================================================================================
File: requests\request.controller.js
Size: 2.39 kB
================================================================================

// requests/request.controller.js
const Joi = require('joi');
const validateRequest = require('_middleware/validate-request');
const requestService = require('./request.service');

module.exports = {
  getAll,
  getById,
  createSchema,
  create,
  updateSchema,
  update,
  delete: _delete
};

// ------------------ Schemas ------------------

function createSchema(req, res, next) {
  const schema = Joi.object({
    accountId: Joi.number().required(),
    employeeEmail: Joi.string().email().optional(),
    type: Joi.string().valid('equipment', 'leave', 'resources').required(),
    items: Joi.string().trim().min(1).required(),
    quantity: Joi.number().integer().min(1).required(),
    status: Joi.string().valid('pending', 'approved', 'disapproved', 'rejected').optional()
  });
  validateRequest(req, next, schema);
}

function updateSchema(req, res, next) {
  const schema = Joi.object({
    accountId: Joi.number().optional(),
    employeeEmail: Joi.string().email().optional(),
    type: Joi.string().valid('equipment', 'leave', 'resources').optional(),
    items: Joi.string().trim().min(1).optional(),
    quantity: Joi.number().integer().min(1).optional(),
    status: Joi.string().valid('pending', 'approved', 'disapproved', 'rejected').optional()
  });
  validateRequest(req, next, schema);
}

// ------------------ Handlers ------------------

async function getAll(req, res, next) {
  try {
    const list = await requestService.getAll();
    res.json(list);
  } catch (err) {
    next(err);
  }
}

async function getById(req, res, next) {
  try {
    const r = await requestService.getById(req.params.requestId);
    if (!r) return res.sendStatus(404);
    res.json(r);
  } catch (err) {
    next(err);
  }
}

async function create(req, res, next) {
  try {
    const created = await requestService.create(req.body);
    res.status(201).json(created);
  } catch (err) {
    next(err);
  }
}

async function update(req, res, next) {
  try {
    const updated = await requestService.update(req.params.requestId, req.body);
    res.json(updated);
  } catch (err) {
    next(err);
  }
}

async function _delete(req, res, next) {
  try {
    await requestService.delete(req.params.requestId);
    res.json({ message: 'Request deleted successfully' });
  } catch (err) {
    next(err);
  }
}


================================================================================
File: requests\request.model.js
Size: 2.21 kB
================================================================================

// requests/request.model.js
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Request = sequelize.define(
    'Request',
    {
      id: { // ✅ Use standard naming for Sequelize
        type: DataTypes.INTEGER.UNSIGNED,
        autoIncrement: true,
        primaryKey: true,
      },

      accountId: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: false,
        references: {
          model: 'accounts', // ✅ FK to accounts table
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },

      type: {
        type: DataTypes.ENUM('equipment', 'leave', 'resources'),
        allowNull: false,
      },

      items: {
        type: DataTypes.STRING(255), // ✅ clear name and reasonable length
        allowNull: false,
      },

      quantity: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: false,
        defaultValue: 1,
      },

      status: {
        type: DataTypes.ENUM('pending', 'approved', 'disapproved', 'rejected'),
        allowNull: false,
        defaultValue: 'pending',
      },

      createdAt: { // ✅ consistent with Sequelize timestamp standards
        type: DataTypes.DATE,
        allowNull: false,
        defaultValue: DataTypes.NOW,
        field: 'created',
      },

      updatedAt: {
        type: DataTypes.DATE,
        allowNull: true,
        field: 'updated',
      },
    },
    {
      tableName: 'requests',
      timestamps: true, // ✅ enables createdAt and updatedAt automatically
      createdAt: 'created',
      updatedAt: 'updated',
    }
  );

  // 🔗 Associations
  Request.associate = (models) => {
    if (models.Account) {
      Request.belongsTo(models.Account, {
        foreignKey: 'accountId',
        targetKey: 'id',
        as: 'Account',
      });
    }

    // ✅ One-to-one with Workflow (if applicable)
    if (models.Workflow) {
      Request.hasOne(models.Workflow, {
        foreignKey: 'requestId',
        as: 'Workflow',
        onDelete: 'CASCADE',
        onUpdate: 'CASCADE',
      });
    }
  };

  return Request;
};


================================================================================
File: requests\request.service.js
Size: 6.01 kB
================================================================================

// requests/request.service.js
const db = require('_helpers/db');

module.exports = {
  getAll,
  getById,
  create,
  update,
  delete: _delete,
};

const ALLOWED_TYPES = ['equipment', 'leave', 'resources'];
const ALLOWED_STATUS = ['pending', 'approved', 'disapproved', 'rejected'];

// ------------------------- Get all -------------------------
async function getAll() {
  return await db.Request.findAll({
    include: [
      {
        model: db.Account,
        attributes: ['id', 'email', 'firstName', 'lastName'],
        required: false,
      },
    ],
    order: [['created', 'DESC']],
  });
}

// ------------------------- Get by ID -------------------------
async function getById(requestId) {
  if (requestId === undefined || requestId === null) return null;
  return await db.Request.findByPk(requestId, {
    include: [
      {
        model: db.Account,
        attributes: ['id', 'email', 'firstName', 'lastName'],
        required: false,
      },
    ],
  });
}

// ------------------------- Helpers -------------------------
async function resolveAccountIdFromEmail(email) {
  if (!email) return null;
  const account = await db.Account.findOne({ where: { email } });
  return account ? account.id : null;
}

// ------------------------- Create -------------------------
/**
 * params expected:
 *  { accountId?, employeeEmail?, type, items, quantity, status? }
 */
async function create(params) {
  // 🔹 Resolve accountId if not provided
  let accountId = params.accountId ?? null;
  if (!accountId && params.employeeEmail) {
    accountId = await resolveAccountIdFromEmail(params.employeeEmail);
  }

  if (!accountId) throw 'accountId is required';

  // 🔹 Validate type
  if (!ALLOWED_TYPES.includes((params.type || '').toString())) {
    throw 'Invalid request type';
  }

  // 🔹 Validate items
  if (!params.items || String(params.items).trim() === '') {
    throw 'items is required';
  }

  // 🔹 Validate quantity
  const qty = Number(params.quantity);
  if (!Number.isFinite(qty) || qty < 1) {
    throw 'quantity must be an integer >= 1';
  }

  // 🔹 Validate status if provided
  if (params.status && !ALLOWED_STATUS.includes(params.status)) {
    throw 'Invalid status';
  }

  // ✅ Create request record
  const request = await db.Request.create({
    accountId,
    type: params.type,
    items: String(params.items).trim(),
    quantity: Math.trunc(qty),
    status: params.status || 'pending',
    created: new Date(),
  });

  const requestId = request.id ?? request.requestId ?? null;

  // ✅ Automatically create a linked workflow
  try {
    const account = await db.Account.findByPk(accountId);
    const employee = await db.Employee.findOne({ where: { accountId } });

    // 🧠 Convert JSON string or array into readable text
    let itemDescription = '';
    if (Array.isArray(params.items)) {
      itemDescription = params.items
        .map(i => `${i.name}${i.quantity ? ` (x${i.quantity})` : ''}`)
        .join(', ');
    } else if (typeof params.items === 'string') {
      try {
        const parsed = JSON.parse(params.items);
        if (Array.isArray(parsed)) {
          itemDescription = parsed
            .map(i => `${i.name}${i.quantity ? ` (x${i.quantity})` : ''}`)
            .join(', ');
        } else {
          itemDescription = params.items;
        }
      } catch {
        itemDescription = params.items;
      }
    }

    const readableDetails = `${account.firstName} ${account.lastName} requested ${params.quantity}x ${itemDescription}`;

    await db.Workflow.create({
      requestId,
      employeeId: employee ? employee.EmployeeID : null,
      type: `Request-${params.type}`,
      details: readableDetails,
      status: 'pending',
    });
  } catch (err) {
    console.error('⚠️ Failed to create workflow for request:', err);
  }

  return await getById(requestId);
}

// ------------------------- Update -------------------------
async function update(requestId, params) {
  const request = await db.Request.findByPk(requestId);
  if (!request) throw 'Request not found';

  // 🔹 Resolve account if needed
  if (!params.accountId && params.employeeEmail) {
    const resolved = await resolveAccountIdFromEmail(params.employeeEmail);
    if (resolved) params.accountId = resolved;
  }

  // 🔹 Validate related account
  if (params.accountId && params.accountId !== request.accountId) {
    const account = await db.Account.findByPk(params.accountId);
    if (!account) throw 'Related account not found for new accountId';
  }

  // 🔹 Validate type/status
  if (params.type && !ALLOWED_TYPES.includes(params.type))
    throw 'Invalid request type';
  if (params.status && !ALLOWED_STATUS.includes(params.status))
    throw 'Invalid status';

  // 🔹 Validate items/quantity
  if (Object.prototype.hasOwnProperty.call(params, 'items')) {
    if (!params.items || String(params.items).trim() === '')
      throw 'items cannot be empty';
    request.items = String(params.items).trim();
  }

  if (Object.prototype.hasOwnProperty.call(params, 'quantity')) {
    const qty = Number(params.quantity);
    if (!Number.isFinite(qty) || qty < 1)
      throw 'quantity must be an integer >= 1';
    request.quantity = Math.trunc(qty);
  }

  // 🔹 Copy other allowed fields
  const allowed = ['accountId', 'type', 'status'];
  for (const f of allowed) {
    if (Object.prototype.hasOwnProperty.call(params, f)) {
      request[f] = params[f];
    }
  }

  request.updated = new Date();
  await request.save();

  const pk = request.requestId ?? request.id ?? null;
  return await getById(pk);
}

// ------------------------- Delete -------------------------
async function _delete(requestId) {
  const r = await db.Request.findByPk(requestId);
  if (!r) throw 'Request not found';
  await r.destroy();
}


================================================================================
File: server.js
Size: 1.64 kB
================================================================================

// server.js
require('rootpath')();
const express = require('express');
const app = express();
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const cors = require('cors');
const errorHandler = require('_middleware/error-handler');

// ✅ Middleware
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());
app.use(cookieParser());

// ✅ Allow CORS requests from any origin with credentials
app.use(cors({
  origin: (origin, callback) => callback(null, true),
  credentials: true
}));

// ✅ Import route controllers
const accountRoutes = require('./accounts/accounts.controller');
const employeeRoutes = require('./employees/employee.controller');
const departmentRoutes = require('./departments'); // folder with index.js exporting router
const requestRoutes = require('./requests');       // folder with index.js exporting router
const workflowRoutes = require('./workflows/workflow.controller');
const positionRoutes = require('./positions/position.controller'); // ✅ fixed path

// ✅ Mount routes
app.use('/accounts', accountRoutes);
app.use('/employees', employeeRoutes);
app.use('/departments', departmentRoutes);
app.use('/requests', requestRoutes);
app.use('/workflows', workflowRoutes);
app.use('/positions', positionRoutes); // ✅ now /positions not /api/positions

// 🧩 Global error handler
app.use(errorHandler);

// ✅ Start server
const port = process.env.NODE_ENV === 'production'
  ? (process.env.PORT || 80)
  : 4000;

app.listen(port, () => console.log(`✅ Server listening on port ${port}`));


================================================================================
File: swagger.yaml
Size: 23.7 kB
================================================================================


openapi: 3.0.0
info:
  title: Node.js Sign-up and Verification API
  description: Node.js and MySQL - API with email sign-up, verification, authentication and forgot password
  version: 1.0.0

servers:
  - url: http://localhost:4000
    description: Local development server

paths:
  /accounts/authenticate:
    post:
      summary: Authenticate account credentials and return a JWT token and a cookie with a refresh token
      description: Accounts must be verified before authenticating.
      operationId: authenticate
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
              required:
                - email
                - password
      responses:
        "200":
          description: Account details, a JWT access token and a refresh token cookie
          headers:
            Set-Cookie:
              description: "`refreshToken`"
              schema:
                type: string
                example: refreshToken=51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550; Path=/; Expires=Tue, 16 Jun 2020 09:14:17 GMT; HttpOnly
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  isVerified:
                    type: boolean
                    example: true
                  jwtToken:
                    type: string
                    example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZWIxMmUxOTdlMDZhNzZjY2RlZmMxMjEiLCJpZCI6IjVlYjEyZTE5N2UwNmE3NmNjZGVmYzEyMSIsImlhdCI6MTU4ODc1ODE1N30.xR9H0STbFOpSkuGA9jHNZOJ6eS7umHHqKRhI807YT1Y"
        "400":
          description: The email or password is incorrect
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Email or password is incorrect"
  /accounts/refresh-token:
    post:
      summary: Use a refresh token to generate a new JWT token and a new refresh token
      description: The refresh token is sent and returned via cookies.
      operationId: refreshToken
      parameters:
        - in: cookie
          name: refreshToken
          description: The `refreshToken` cookie
          schema:
            type: string
            example: 51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550
      responses:
        "200":
          description: Account details, a JWT access token and a new refresh token cookie
          headers:
            Set-Cookie:
              description: "`refreshToken`"
              schema:
                type: string
                example: refreshToken=51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550; Path=/; Expires=Tue, 16 Jun 2020 09:14:17 GMT; HttpOnly
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  isVerified:
                    type: boolean
                    example: true
                  jwtToken:
                    type: string
                    example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZWIxMmUxOTdlMDZhNzZjY2RlZmMxMjEiLCJpZCI6IjVlYjEyZTE5N2UwNmE3NmNjZGVmYzEyMSIsImlhdCI6MTU4ODc1ODE1N30.xR9H0STbFOpSkuGA9jHNZOJ6eS7umHHqKRhI807YT1Y"
        "400":
          description: The refresh token is invalid, revoked or expired
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts/revoke-token:
    post:
      summary: Revoke a refresh token
      description: Admin users can revoke the tokens of any account, regular users can only revoke their own tokens.
      operationId: revokeToken
      security:
        - bearerAuth: []
      parameters:
        - in: cookie
          name: refreshToken
          description: The refresh token can be sent in a cookie or the post body, if both are sent the token in the body is used.
          schema:
            type: string
            example: 51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550"
      responses:
        "200":
          description: The refresh token was successfully revoked
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Token revoked"
        "400":
          description: The refresh token is invalid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
  /accounts/register:
    post:
      summary: Register a new user account and send a verification email
      description: The first account registered in the system is assigned the `Admin` role, other accounts are assigned the `User` role.
      operationId: register
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                acceptTerms:
                  type: boolean
              required:
                - title
                - firstName
                - lastName
                - email
                - password
                - confirmPassword
                - acceptTerms
      responses:
        "200":
          description: The registration request was successful and a verification email has been sent to the specified email address
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Registration successful, please check your email for verification instructions"
  /accounts/verify-email:
    post:
      summary: Verify a new account with a verification token received by email after registration
      operationId: verifyEmail
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
              required:
                - token
      responses:
        "200":
          description: Verification was successful so you can now login to the account
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Verification successful, you can now login"
        "400":
          description: Verification failed due to an invalid token
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Verification failed"
  /accounts/forgot-password:
    post:
      summary: Submit email address to reset the password on an account
      operationId: forgotPassword
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  example: "jason@example.com"
              required:
                - email
      responses:
        "200":
          description: The request was received and an email has been sent to the specified address with password reset instructions (if the email address is associated with an account)
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Please check your email for password reset instructions"
  /accounts/validate-reset-token:
    post:
      summary: Validate the reset password token received by email after submitting to the /accounts/forgot-password route
      operationId: validateResetToken
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
              required:
                - token
      responses:
        "200":
          description: Token is valid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Token is valid"
        "400":
          description: Token is invalid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts/reset-password:
    post:
      summary: Reset the password for an account
      operationId: resetPassword
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
                password:
                  type: string
                  example: "newPass123"
                confirmPassword:
                  type: string
                  example: "newPass123"
              required:
                - token
                - password
                - confirmPassword
      responses:
        "200":
          description: Password reset was successful so you can now login to the account with the new password
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Password reset successful, you can now login"
        "400":
          description: Password reset failed due to an invalid token
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts:
    get:
      summary: Get a list of all accounts
      description: Restricted to admin users.
      operationId: getAllAccounts
      security:
        - bearerAuth: []
      responses:
        "200":
          description: An array of all accounts
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    id:
                      type: string
                      example: "5eb12e197e06a76ccdefc121"
                    title:
                      type: string
                      example: "Mr"
                    firstName:
                      type: string
                      example: "Jason"
                    lastName:
                      type: string
                      example: "Watmore"
                    email:
                      type: string
                      example: "jason@example.com"
                    role:
                      type: string
                      example: "Admin"
                    created:
                      type: string
                      example: "2020-05-05T09:12:57.848Z"
                    updated:
                      type: string
                      example: "2020-05-08T03:11:21.553Z"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    post:
      summary: Create a new account
      description: Restricted to admin users.
      operationId: createAccount
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                role:
                  type: string
                  enum: [Admin, User]
              required:
                - title
                - firstName
                - lastName
                - email
                - password
                - confirmPassword
                - role
      responses:
        "200":
          description: Account created successfully, verification is not required for accounts created with this endpoint. The details of the new account are returned.
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
        "400":
          description: Email is already registered
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Email 'jason@example.com' is already registered"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
  /accounts/{id}:
    parameters:
      - in: path
        name: id
        description: Account id
        required: true
        example: "5eb12e197e06a76ccdefc121"
        schema:
          type: string
    get:
      summary: Get a single account by id
      description: Admin users can access any account, regular users are restricted to their own account.
      operationId: getAccountById
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Details of the specified account
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  updated:
                    type: string
                    example: "2020-05-08T03:11:21.553Z"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    put:
      summary: Update an account
      description: Admin users can update any account including role, regular users are restricted to their own account and cannot update role.
      operationId: updateAccount
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                role:
                  type: string
                  enum: [Admin, User]
      responses:
        "200":
          description: Account updated successfully. The details of the updated account are returned.
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  updated:
                    type: string
                    example: "2020-05-08T03:11:21.553Z"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    delete:
      summary: Delete an account
      description: Admin users can delete any account, regular users are restricted to their own account.
      operationId: deleteAccount
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Account deleted successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Account deleted successfully"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  responses:
    UnauthorizedError:
      description: Access token is missing or invalid, or the user does not have access to perform the action
      content:
        application/json:
          schema:
            type: object
            properties:
              message:
                type: string
                example: "Unauthorized"
    NotFoundError:
      description: Not Found
      content:
        application/json:
          schema:
            type: object
            properties:
              message:
                type: string
                example: "Not Found"


================================================================================
File: workflows\workflow.controller.js
Size: 2.03 kB
================================================================================

// workflows/workflow.controller.js
const express = require('express');
const router = express.Router();
const workflowService = require('./workflow.service');

// ====== CREATE WORKFLOW ======
router.post('/', async (req, res, next) => {
  try {
    const workflow = await workflowService.create(req.body);
    res.status(201).json(workflow);
  } catch (err) {
    console.error('❌ Error creating workflow:', err);
    next(err);
  }
});

// ====== GET ALL WORKFLOWS (with optional employeeId filter) ======
router.get('/', async (req, res, next) => {
  try {
    const { employeeId } = req.query;
    const workflows = await workflowService.getAll(employeeId);
    res.json(workflows);
  } catch (err) {
    console.error('❌ Error fetching workflows:', err);
    next(err);
  }
});

// ====== GET WORKFLOW BY ID ======
router.get('/:id', async (req, res, next) => {
  try {
    const workflow = await workflowService.getById(req.params.id);
    res.json(workflow);
  } catch (err) {
    console.error('❌ Error fetching workflow by ID:', err);
    next(err);
  }
});

// ====== UPDATE WORKFLOW ======
router.put('/:id', async (req, res, next) => {
  try {
    const workflow = await workflowService.update(req.params.id, req.body);
    res.json(workflow);
  } catch (err) {
    console.error('❌ Error updating workflow:', err);
    next(err);
  }
});

// ====== APPROVE WORKFLOW ======
router.put('/:id/approve', async (req, res, next) => {
  try {
    const workflow = await workflowService.approve(req.params.id);
    res.json(workflow);
  } catch (err) {
    console.error('❌ Error approving workflow:', err);
    next(err);
  }
});

// ====== REJECT WORKFLOW ======
router.put('/:id/reject', async (req, res, next) => {
  try {
    const workflow = await workflowService.reject(req.params.id);
    res.json(workflow);
  } catch (err) {
    console.error('❌ Error rejecting workflow:', err);
    next(err);
  }
});

module.exports = router;


================================================================================
File: workflows\workflow.model.js
Size: 2.05 kB
================================================================================

// models/workflow.model.js
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Workflow = sequelize.define(
    'Workflow',
    {
      id: {
        type: DataTypes.INTEGER.UNSIGNED,
        autoIncrement: true,
        primaryKey: true,
      },

      employeeId: {
        type: DataTypes.STRING(20),
        allowNull: false,
        references: {
          model: 'employees',
          key: 'EmployeeID'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },

      requestId: {
        type: DataTypes.INTEGER.UNSIGNED,
        allowNull: true,
        references: {
          model: 'requests',
          key: 'id',
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE',
      },

      type: {
        type: DataTypes.STRING(50),
        allowNull: false,
      },

      details: {
        type: DataTypes.JSON,
        allowNull: false,
      },

      status: {
        type: DataTypes.ENUM('pending', 'approved', 'rejected', 'completed'),
        allowNull: false,
        defaultValue: 'pending',
      },

      createdAt: {
        type: DataTypes.DATE,
        allowNull: false,
        defaultValue: DataTypes.NOW,
        field: 'created',
      },

      updatedAt: {
        type: DataTypes.DATE,
        allowNull: false,
        defaultValue: DataTypes.NOW,
        field: 'updated',
      },
    },
    {
      tableName: 'workflows',
      timestamps: true,
      createdAt: 'created',
      updatedAt: 'updated',
    }
  );

  // 🔗 Associations
  Workflow.associate = (models) => {
    if (models.Employee) {
      Workflow.belongsTo(models.Employee, {
        foreignKey: 'employeeId',
        targetKey: 'EmployeeID',
        as: 'Employee',
      });
    }

    if (models.Request) {
      Workflow.belongsTo(models.Request, {
        foreignKey: 'requestId',
        targetKey: 'id',
        as: 'Request',
      });
    }
  };

  return Workflow;
};


================================================================================
File: workflows\workflow.service.js
Size: 2.85 kB
================================================================================

// workflows/workflow.service.js
const db = require('_helpers/db');

module.exports = {
  create,
  getAll,
  getById,
  update,
  approve,
  reject
};

// ====== CREATE ======
async function create(params) {
  // ensure employee exists
  const employee = await db.Employee.findByPk(params.employeeId, {
    include: [{ model: db.Department, as: 'Department' }]
  });
  if (!employee) throw `Employee ${params.employeeId} not found`;

  // build readable details string
  let details = '';
  switch (params.type) {
    case 'Onboarding':
      details = `Onboarded to ${employee.Department ? employee.Department.departmentName : 'No Department'} as ${employee.position || 'Unassigned'} on ${employee.hireDate || 'N/A'}`;
      break;

    case 'Department Transfer':
      details = `From: ${params.fromDepartmentName || 'N/A'} → To: ${params.toDepartmentName || 'N/A'}`;
      break;

    case 'Employee Updated':
      details = params.changes
        ? `Updated fields: ${Object.keys(params.changes).join(', ')}`
        : 'Employee information updated';
      break;

    case 'Employee Deleted':
      details = `Removed from ${params.departmentName || 'No Department'}`;
      break;

    default:
      details = params.details || 'General workflow logged';
      break;
  }

  return await db.Workflow.create({
    employeeId: params.employeeId,
    type: params.type || 'General',
    details,
    status: params.status || 'pending'
  });
}

// ====== GET ALL (optional filter by employeeId) ======
async function getAll(employeeId) {
  const where = {};
  if (employeeId) {
    where.employeeId = employeeId;
  }

  const workflows = await db.Workflow.findAll({
    where,
    include: [{ model: db.Employee }],
    order: [['createdAt', 'DESC']]
  });

  return workflows.map(wf => wf.toJSON());
}

// ====== GET BY ID ======
async function getById(id) {
  const wf = await db.Workflow.findByPk(id, {
    include: [{ model: db.Employee }]
  });
  if (!wf) throw 'Workflow not found';
  return wf.toJSON();
}

// ====== UPDATE ======
async function update(id, params) {
  const workflow = await db.Workflow.findByPk(id);
  if (!workflow) throw 'Workflow not found';

  Object.assign(workflow, params);
  await workflow.save();
  return workflow.toJSON();
}

// ====== APPROVE ======
async function approve(id) {
  const workflow = await db.Workflow.findByPk(id);
  if (!workflow) throw 'Workflow not found';

  workflow.status = 'approved';
  await workflow.save();
  return workflow.toJSON();
}

// ====== REJECT ======
async function reject(id) {
  const workflow = await db.Workflow.findByPk(id);
  if (!workflow) throw 'Workflow not found';

  workflow.status = 'rejected';
  await workflow.save();
  return workflow.toJSON();
}


================================================================================
File: _helpers\db.js
Size: 6.65 kB
================================================================================

// src/_helpers/db.js
const fs = require('fs');
const path = require('path');
const mysql = require('mysql2/promise');
const { Sequelize } = require('sequelize');

const configPath = path.resolve(__dirname, '..', 'config.json');
let fileConfig = {};

// ✅ Load config.json if available
if (fs.existsSync(configPath)) {
  try {
    fileConfig = require(configPath);
  } catch (e) {
    console.warn('[DB] Failed to parse config.json:', e.message);
  }
}

// ✅ Database configuration (priority: environment → config.json → default)
const DB = {
  host: process.env.DB_HOST || fileConfig.database?.host || 'localhost',
  port: Number(process.env.DB_PORT || fileConfig.database?.port || 3306),
  user: process.env.DB_USER || fileConfig.database?.user || 'root',
  password: process.env.DB_PASSWORD || fileConfig.database?.password || '',
  database: process.env.DB_NAME || fileConfig.database?.database || 'node-mysql-signup-verification-api'
};

// ✅ Sync and connection settings
const DB_SYNC = process.env.DB_SYNC || fileConfig.dbSync || 'forsce'; // 'alter' | 'force' | 'none'
const SKIP_DB_CREATE = (process.env.SKIP_DB_CREATE || 'false').toLowerCase() === 'true';
const MAX_RETRIES = Number(process.env.DB_CONN_RETRIES || 5);
const RETRY_DELAY_MS = Number(process.env.DB_CONN_RETRY_DELAY_MS || 3000);

// ✅ Exportable db object
module.exports = db = {
  sequelize: null,
  Sequelize
};

(async function initialize() {
  if (!DB.host || !DB.user || !DB.database) {
    console.error('[DB] Missing configuration. Please check DB_HOST, DB_USER, and DB_NAME.');
    process.exit(1);
  }

  // 🔁 Retry connection to MySQL
  let attempt = 0;
  let connection = null;

  while (attempt < MAX_RETRIES) {
    attempt++;
    try {
      connection = await mysql.createConnection({
        host: DB.host,
        port: DB.port,
        user: DB.user,
        password: DB.password
      });
      console.info(`[DB] Connected to MySQL (attempt ${attempt}).`);
      break;
    } catch (err) {
      console.warn(`[DB] Connection attempt ${attempt}/${MAX_RETRIES} failed: ${err.message}`);
      if (attempt >= MAX_RETRIES) {
        console.error('[DB] Max connection attempts reached. Exiting.');
        process.exit(1);
      }
      await new Promise(r => setTimeout(r, RETRY_DELAY_MS));
    }
  }

  // 🏗️ Ensure database exists
  try {
    if (!SKIP_DB_CREATE) {
      await connection.query(`CREATE DATABASE IF NOT EXISTS \`${DB.database}\`;`);
      console.info(`[DB] Ensured database "${DB.database}" exists.`);
    } else {
      console.info('[DB] SKIP_DB_CREATE=true — skipping CREATE DATABASE step.');
    }
  } catch (err) {
    console.error('[DB] Failed ensuring database exists:', err.message);
    process.exit(1);
  } finally {
    if (connection) await connection.end().catch(() => {});
  }

  // 🔧 Initialize Sequelize
  const sequelize = new Sequelize(DB.database, DB.user, DB.password, {
    host: DB.host,
    port: DB.port,
    dialect: 'mysql',
    logging: process.env.NODE_ENV === 'production' ? false : (msg) => console.debug('[sequelize]', msg),
    define: { timestamps: false },
    pool: { max: 10, min: 0, acquire: 30000, idle: 10000 }
  });

  db.sequelize = sequelize;

  // 🧩 Import models
  try {
    db.Account = require(path.resolve(__dirname, '..', 'accounts', 'account.model.js'))(sequelize);
    db.RefreshToken = require(path.resolve(__dirname, '..', 'accounts', 'refresh-token.model.js'))(sequelize);
    db.Employee = require(path.resolve(__dirname, '..', 'employees', 'employee.model.js'))(sequelize);
    db.Department = require(path.resolve(__dirname, '..', 'departments', 'department.model.js'))(sequelize);
    db.Request = require(path.resolve(__dirname, '..', 'requests', 'request.model.js'))(sequelize);
    db.Workflow = require(path.resolve(__dirname, '..', 'workflows', 'workflow.model.js'))(sequelize);
    db.Position = require(path.resolve(__dirname, '..', 'positions', 'position.model.js'))(sequelize); // ✅ Position model
  } catch (err) {
    console.error('[DB] Failed to load models:', err);
    process.exit(1);
  }

  // 🔗 Associate models if needed
  Object.keys(db).forEach(key => {
    const model = db[key];
    if (model?.associate) {
      try {
        model.associate(db);
      } catch (e) {
        console.warn(`[DB] associate() failed for ${key}: ${e.message}`);
      }
    }
  });

  // 🔐 Define relationships
  if (db.Account && db.RefreshToken) {
    db.Account.hasMany(db.RefreshToken, { foreignKey: 'accountId', onDelete: 'CASCADE' });
    db.RefreshToken.belongsTo(db.Account, { foreignKey: 'accountId' });
  }

  if (db.Account && db.Employee) {
    db.Account.hasOne(db.Employee, { foreignKey: 'accountId', onDelete: 'CASCADE' });
    db.Employee.belongsTo(db.Account, { foreignKey: 'accountId' });
  }

  if (db.Department && db.Employee) {
    db.Department.hasMany(db.Employee, { foreignKey: 'departmentId', sourceKey: 'id', onDelete: 'SET NULL' });
    db.Employee.belongsTo(db.Department, { foreignKey: 'departmentId', targetKey: 'id' });
  }

  if (db.Account && db.Request) {
    db.Account.hasMany(db.Request, { foreignKey: 'accountId', onDelete: 'CASCADE' });
    db.Request.belongsTo(db.Account, { foreignKey: 'accountId' });
  }

  if (db.Employee && db.Workflow) {
    db.Employee.hasMany(db.Workflow, { foreignKey: 'employeeId', sourceKey: 'EmployeeID', onDelete: 'CASCADE' });
    db.Workflow.belongsTo(db.Employee, { foreignKey: 'employeeId', targetKey: 'EmployeeID' });
  }

  if (db.Position && db.Employee) {
    db.Position.hasMany(db.Employee, { foreignKey: 'positionId', sourceKey: 'id', onDelete: 'SET NULL' });
    db.Employee.belongsTo(db.Position, { foreignKey: 'positionId', targetKey: 'id' });
  }

  // 🧭 Sync database schema
  try {
    if (DB_SYNC === 'none') {
      console.info('[DB] DB_SYNC=none — skipping sequelize.sync().');
    } else if (DB_SYNC === 'force') {
      console.warn('[DB] DB_SYNC=force — dropping and recreating all tables...');
      await sequelize.sync({ force: true });
      console.info('[DB] Tables recreated successfully.');
    } else {
      console.info('[DB] DB_SYNC=alter — syncing tables to match models...');
      await sequelize.sync({ alter: true });
      console.info('[DB] Tables updated successfully. ');
    }
  } catch (err) {
    console.error('[DB] sequelize.sync failed:', err);
    process.exit(1);
  }

  console.info('[DB] Initialization complete. ✅✅✅');
})();


================================================================================
File: _helpers\role.js
Size: 63 B
================================================================================

module.exports = {
    Admin: 'Admin',
    User: 'User'
  };

================================================================================
File: _helpers\send-email.js
Size: 2.24 kB
================================================================================

// _helpers/send-email.js
const nodemailer = require('nodemailer');
const config = require('config.json');

module.exports = sendEmail;

async function sendEmail({ to, subject, html, from = config.emailFrom }) {
  let transporter;
  let usedTestAccount = false;

  // Try to use configured SMTP options first (if present)
  if (config && config.smtpOptions && config.smtpOptions.host) {
    try {
      transporter = nodemailer.createTransport(config.smtpOptions);
      // verify() will throw if auth or connection fails
      await transporter.verify();
      console.log('SMTP transporter verified using config.smtpOptions.');
    } catch (err) {
      console.error('Configured SMTP verify failed:', err && err.message ? err.message : err);
      transporter = null;
    }
  }

  // If we don't have a working transporter from config, create a test account
  if (!transporter) {
    try {
      const testAccount = await nodemailer.createTestAccount();
      transporter = nodemailer.createTransport({
        host: testAccount.smtp.host,
        port: testAccount.smtp.port,
        secure: testAccount.smtp.secure,
        auth: { user: testAccount.user, pass: testAccount.pass }
      });
      usedTestAccount = true;
      console.log('Using nodemailer test account:', testAccount.user);
    } catch (err) {
      console.error('Failed to create nodemailer test account:', err && err.message ? err.message : err);
      // If we can't create a test account either, fail gracefully by returning null
      return null;
    }
  }

  // Try to send the message
  try {
    const info = await transporter.sendMail({ from, to, subject, html });
    console.log('Email send attempted. messageId:', info && info.messageId ? info.messageId : 'none');

    if (usedTestAccount && nodemailer.getTestMessageUrl) {
      const previewUrl = nodemailer.getTestMessageUrl(info);
      if (previewUrl) console.log('Preview URL (open in browser):', previewUrl);
    }

    return info;
  } catch (err) {
    console.error('Failed to send email:', err && err.message ? err.message : err);
    // Don't throw — return null so registration can continue while you debug.
    return null;
  }
}


================================================================================
File: _helpers\swagger.js
Size: 305 B
================================================================================

const express = require('express');
const router = express.Router();
const swaggerUi = require('swagger-ui-express');
const YAML = require('yamljs');
const swaggerDocument = YAML.load('./swagger.yaml');

router.use('/', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

module.exports = router;

================================================================================
File: _middleware\authorize.js
Size: 2.82 kB
================================================================================

const { expressjwt } = require('express-jwt');
const config = require('config.json');
const db = require('_helpers/db');

module.exports = authorize;

function authorize(roles = []) {
  // allow single role string
  if (typeof roles === 'string') {
    roles = [roles];
  }

  return [
    // authenticate JWT token and attach decoded payload to req.user
    expressjwt({
      secret: config.secret,
      algorithms: ['HS256'],
      requestProperty: 'user', // ensure payload is on req.user (not req.auth)
      // support tokens from Authorization header (Bearer) or cookie named 'refreshToken'
      getToken: req => {
        if (req.headers && req.headers.authorization) {
          const parts = req.headers.authorization.split(' ');
          if (parts.length === 2 && /^Bearer$/i.test(parts[0])) {
            return parts[1];
          }
        }
        if (req.cookies && req.cookies.refreshToken) {
          return req.cookies.refreshToken;
        }
        return null;
      }
    }),

    // authorize based on user role and attach helper properties
    async (req, res, next) => {
      try {
        // express-jwt should populate req.user; if not, return 401
        if (!req.user) {
          console.error('authorize: no req.user (token missing or invalid)');
          return res.status(401).json({ message: 'Unauthorized' });
        }

        // token payload may use different claim names
        const userId = req.user.id || req.user.sub || req.user.userId;
        if (!userId) {
          console.error('authorize: token missing id/sub/userId claim', req.user);
          return res.status(401).json({ message: 'Unauthorized' });
        }

        // load account from DB
        const account = await db.Account.findByPk(userId);
        if (!account) {
          console.error('authorize: no account found for id', userId);
          return res.status(401).json({ message: 'Unauthorized' });
        }

        // check role if roles were provided
        if (roles.length && !roles.includes(account.role)) {
          console.warn(`authorize: account role "${account.role}" not authorized for ${JSON.stringify(roles)}`);
          return res.status(401).json({ message: 'Unauthorized' });
        }

        // attach role and ownsToken helper to req.user (keep original decoded payload too)
        req.user.role = account.role;
        const refreshTokens = await account.getRefreshTokens();
        req.user.ownsToken = token => !!refreshTokens.find(x => x.token === token);

        next();
      } catch (err) {
        console.error('authorize middleware error:', err);
        // return 500 for unexpected errors
        return res.status(500).json({ message: err.message });
      }
    }
  ];
}


================================================================================
File: _middleware\error-handler.js
Size: 563 B
================================================================================

module.exports = errorHandler;

function errorHandler(err, req, res, next) {
  switch (true) {
    case typeof err === 'string':
      // custom application error
      const is404 = err.toLowerCase().endsWith('not found');
      const statusCode = is404 ? 404 : 400;
      return res.status(statusCode).json({ message: err });
    case err.name === 'UnauthorizedError':
      // jwt authentication error
      return res.status(401).json({ message: 'Unauthorized' });
    default:
      return res.status(500).json({ message: err.message });
  }
}

================================================================================
File: _middleware\validate-request.js
Size: 470 B
================================================================================

module.exports = validateRequest;

function validateRequest(req, next, schema) {
  const options = {
    abortEarly: false, // include all errors
    allowUnknown: true, // ignore unknown props
    stripUnknown: true // remove unknown props
  };

  const { error, value } = schema.validate(req.body, options);
  if (error) {
    next(`Validation error: ${error.details.map(x => x.message).join(', ')}`);
  } else {
    req.body = value;
    next();
  }
}
